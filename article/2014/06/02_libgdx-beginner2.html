<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A layout example that shows off a responsive pricing table.">
    <title>libGDX入門 その2 カメラとビューポート|ざる魂</title>

    <!--[if lte IE 8]>
    <link rel="stylesheet" href="/css/main-grid-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
    <link rel="stylesheet" href="/css/main-grid.css">
    <!--<![endif]-->

    <!--[if lte IE 8]>
    <link rel="stylesheet" href="/css/layouts/pricing-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
    <link rel="stylesheet" href="/css/layouts/pricing.css">
    <!--<![endif]-->

        <link href="/atom.xml" rel="alternate" title="ざる魂" type="application/atom+xml" />
    

        <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.4.2/pure.css" />
    

        <link rel="stylesheet" href="/css/main.css" />
    

  </head>
  <body>
    <header class="global-header">
      <div class="container">
        <div class="site-header">
          <a href="/"><img src="/img/zarudama-logo.png"></img></a>
          <p>真似て学んで「まねぶ」サル。知られざる我が魂。</p>
        </div>
      </div>
    </header>

    <div class="l-content">
      <div class="information ">

        <div class="pure-menu pure-menu-open pure-menu-horizontal">
          <ul>
            <li><a href="/archives.html">Archives</a></li>
            <li><a href="/tags.html">Tags</a></li>
            <li><a href="/about.html">About</a></li>
          </ul>
        </div>

        <div class="article-header">
  <div class="title">
  <h1><a href="">libGDX入門 その2 カメラとビューポート</a></h1>
  </div>
  <p class="date">2014/6/02</p>
</div>

<div class="content">
  <div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. はじめに</a></li>
<li><a href="#sec-2">2. 物理画面に依存しない画面表示</a></li>
<li><a href="#sec-3">3. カメラとビューポート</a></li>
<li><a href="#sec-4">4. 実際のコーディング</a>
<ul>
<li><a href="#sec-4-1">4.1. カメラの導入</a></li>
<li><a href="#sec-4-2">4.2. ビューポートの導入</a></li>
</ul>
</li>
<li><a href="#sec-5">5. 背景の追加</a></li>
<li><a href="#sec-6">6. カメラの位置調整</a>
<ul>
<li><a href="#sec-6-1">6.1. ワールド軸の描画</a></li>
<li><a href="#sec-6-2">6.2. setToOrthメソッド</a></li>
</ul>
</li>
<li><a href="#sec-7">7. カメラを動かす</a></li>
<li><a href="#sec-8">8. UI用カメラの導入</a>
<ul>
<li><a href="#sec-8-1">8.1. Windowサイズの変更</a></li>
</ul>
</li>
<li><a href="#sec-9">9. タッチ処理</a></li>
<li><a href="#sec-10">10. ソース</a></li>
<li><a href="#sec-11">11. おわりに</a></li>
<li><a href="#sec-12">12. 参考URL</a></li>
<li><a href="#sec-13">13. 参考書籍</a></li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> はじめに</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="http://libgdx.badlogicgames.com/">libGDX</a> を勉強するついでに解説記事を書くシリーズ2回目です。
</p>

<p>
<a href="http://mikio.github.io/article/2014/05/04_libgdx-beginner.html">前回</a> は、プロジェクトを作って、以下のことを学びました。
</p>
<ul class="org-ul">
<li>画像の表示
</li>
<li>キーボードによる操作
</li>
<li>BGMの再生
</li>
<li>効果音の再生
</li>
</ul>

<p>
今回は次のことを学びます。
</p>

<ul class="org-ul">
<li>物理画面に依存しない画面表示
</li>
<li>タッチ処理
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 物理画面に依存しない画面表示</h2>
<div class="outline-text-2" id="text-2">
<p>
物理画面とは何でしょうか？ここでは次のように定義します。
</p>
<ul class="org-ul">
<li>スマホやタブレット画面解像度
</li>
<li>デスクトップのウィンドウサイズ
</li>
</ul>
<p>
Androidには様々な画面サイズがありますし、
iPhoneもモデルチェンジ毎に画面サイズが変化しています。
これら様々な画面サイズのことを考慮しないと、
意図した通りの画面が表示できません。
</p>

<p>
ゲームを作るときの基本として、物理画面でプログラムしないというのがあります。
物理的なディスプレイのサイズに依存した座標管理をすると、
移植性が下がり仕様変更に弱くなったり、
端末毎の画面サイズの違いを吸収できないプログラムになってしまいます。
</p>

<p>
例えば横スクロールアクションを作ったときに、
Aさんの画面は小さいから敵の動きがところ狭しとなるところが、
Bさんの端末だと画面が大きいからフィールドが遠くまで見わたせて楽々プレイできる、
なんてことが発生します。端末によって難易度が変わってくるのです。
</p>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/screen2.png"  alt="screen2.png"/></p>
<p>端末の小さいAさんは、端末の大きいBさんより不利になる</p>
</div>

<p>
実は既にこの問題は、私の手元で発生しています。
下記は、Nexus7(2013)で表示したサンプルの画面です。
</p>

<div class="figure">
<p><img src="/img/libgdx-beginner/2/004.png"  alt="004.png"/></p>
<p>nexus7の画面</p>
</div>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/003.png"  alt="003.png"/></p>
<p>PC版の画面</p>
</div>

<p>
Nexus7版は、PCの画面と全然違いますね。キャラクターや文字が非常に小さくなってます。
これはPC版が640x480の解像度なのに対して、Nexus7版は1920x1200の解像度で表示しているからです。
この状態でゲームを作ってしまったら全然別ものになってしまいますよね。
ちなみにMac持ってないのでiOS系ではどうなるかわかりません。
</p>

<p>
というわけで、どの端末でも公平に画面表示できるようにひと工夫必要になってきます
(こういう処理は、ゲームづくりの序盤でやっておかないと、あとから変更するのは大変なので
さっさと済ませておきたいことのひとつですね)。
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> カメラとビューポート</h2>
<div class="outline-text-2" id="text-3">
<p>
ではどうやってこの問題を解決するか。それにはカメラとビューポートを使用します。
</p>

<p>
カメラとは、ゲームの世界を現実世界のディスプレイに届けるためのオブジェクトです。
</p>

<p>
ビューポートとは、カメラの捉えたゲームの世界を、ディスプレイのどこに表示するかを
決める枠(矩形領域)のことです。
</p>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/screen3.png"  alt="screen3.png"/></p>
<p>カメラとビューポート</p>
</div>

<p>
ビューポートは、ディスプレイサイズと一致しているわけではないことに注意してください。
ゲームのサンプルなどだと一致していることが多いですが、
今回のように様々なディスプレイサイズに対応させる場合は、
一致しなくなることの方が多くなるはずです。また、他の使い方としては、
カメラを2つ用意して一方はゲーム画面、
一方は小さな枠で別のシーンを表示するなんてこともできるかもしれません(やったことないですが)。
</p>

<p>
カメラを使うことにより、カメラとして定義した論理空間でゲームを制御できます。
この空間でやりとりすれば、あとはlibGDXがよろしく画面に表示してくれるわけです。
カメラでできることを列挙してみます。
</p>
<ul class="org-ul">
<li>物理的な画面サイズを気にせず、自分の定義した画面サイズでゲームを構築できる
</li>
<li>ズームイン、ズームアウト、画面を回転させたり、揺らしたりなど、画面全体にかかるエフェクトが簡単にできる
</li>
<li>カメラを動かすことで、スクロール処理が簡単に実装できる
</li>
</ul>
<p>
カメラを導入することでこのような自由が手に入るわけですが、
その代償として操作が複雑になってしまうのも事実です。
コーディング中は、今自分がどこの座標系で何を操作しているかを常に意識する必要があります。
ちょっと大袈裟ですが、慣れれば大したことありません。またこの考えはそのまま3Dプログラミングにも繋がります。
</p>

<p>
座標系には、以下の種類があります。
</p>
<ul class="org-ul">
<li>ワールド座標系。ゲームオブジェクトを置く論理空間。画面サイズは気にしなくて良い。
</li>
<li>カメラ座標系。ワールドのゲームオブジェクトをカメラの枠での座標系で測りなおした座標系。真ん中が原点となる。
</li>
<li>ビューポート座標系。左下を原点とした座標系。
</li>
<li>スクリーン座標系。Android左上を原点とした最終的な座標系。タッチ座標などはOSからこの座標系の値が得られる。
</li>
</ul>

<p>
ビューポート座標系とスクリーン座標系は他では別の呼びかたかもしれません。
座標系を意識する例を示します。
</p>

<p>
たとえば、画面をタッチして、その座標にキャラクターが向って行くのであれば、
タッチ操作で得られた座標(スクリーン座標系)をワールド座標系に変換する必要があります。
</p>

<p>
逆にワールドに落ちているコインなどのアイテムを画面UIのスコア表示に
吸いこまれるようなエフェクトをかけるときは、ワールドからスクリーンへの変換が必要になるでしょう。
</p>

<p>
カメラを使用しなくてもゲームは作れますが、いろいろと応用が効くので、
パズルゲームのような固定画面のゲームしか使わない予定であっても、
使いかたに慣れておいたほうが良いと思います。
</p>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 実際のコーディング</h2>
<div class="outline-text-2" id="text-4">
<p>
講釈が多くなってしまいました。実際のコーディングに進みます。
まずゲームに使用する画面解像度を決定します。
これは、物理的なサイズではなく、論理的なものです。
今回は下記のように定義しました。
</p>

<ul class="org-ul">
<li>横800 x 縦480
</li>
</ul>

<p>
横長の割と無難なサイズです。
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> カメラの導入</h3>
<div class="outline-text-3" id="text-4-1">
<p>
では早速カメラを導入してみましょう。
前回のソースコードに手を入れていきます。
前回のサンプルでは、画面サイズはデフォルトのままでしたが、
今回はターゲットサイズを横800 x 縦480に設定したので、
createメソッド内でカメラを下記のように定義します。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-type">OrthographicCamera</span> <span class="org-variable-name">camera</span>;

<span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">create</span> () {
  &#65306;
  camera = <span class="org-keyword">new</span> <span class="org-type">OrthographicCamera</span>(800, 480);
  &#65306;
}
</pre>
</div>
<p>
フィールドに <code>camera</code> を追加しています。
ちなみになぜこんな長たらしい名前がついてるのかわかりませんが、
2D用のカメラは、 <code>OrthographicCamera</code> クラスといいます。
libGDXのソースコードを見渡しましたが、他に2D用のカメラは見当たらなかったので
<code>OrthographicCamera</code> は2D専用と思って問題ないでしょう。
</p>

<p>
続いて、描画にカメラを反映させるため、 <code>render</code> メソッドを変更します。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">render</span> () {
    :
  Gdx.gl.glClearColor(1, 0, 0, 1);
  Gdx.gl.glClear(<span class="org-constant">GL20</span>.GL_COLOR_BUFFER_BIT);
  camera.update(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152; #1</span>
  batch.setProjectionMatrix(camera.combined); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152; #2</span>
  batch.begin();
  sprite.draw(batch);
    :
}
</pre>
</div>
<p>
 <code>#1</code> でカメラ自身の座標計算(行列演算)をし、 <code>#2</code> でその結果をスプライトに適用させる準備をします。
この処理は定型処理なので、最初のうちは決めごとと思って問題ありません。
</p>


<p>
ここまでの実行結果は下記のとおりです。
</p>

<div class="figure">
<p><img src="/img/libgdx-beginner/2/005.png"  alt="005.png"/></p>
<p>とりあえずカメラ導入</p>
</div>


<p>
なにか変です。画像のサイズが以前に比べて縦長になっています。なぜでしょうか？
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> ビューポートの導入</h3>
<div class="outline-text-3" id="text-4-2">
<p>
原因はビューポートの設定にあります。libGDXは、デフォルトのビューポート設定だと、
物理画面いっぱいに最終画像を引き伸ばします。
今回の場合、カメラの設定を <code>800x480</code> に設定したのに対し、
実際のウィンドウサイズが <code>640 x 480</code> のため歪みがでてしまったのです(横方向に潰れている)。
</p>

<p>
では、ビューポートはどのように設定すれば良いのでしょうか？
libGDXは、OpenGLを直接操作する低レイヤのメソッドも用意してますので、
自分で直接ビューポートをやりくりすることもできます。
しかし、libGDXには、このような面倒な作業を請け負ってくれる、
高レイヤの <code>ViewPort</code> クラスがあります。
今回は、この便利クラスを使うことにしましょう。
</p>

<p>
フィールドに <code>viewport</code> を追加し、createメソッド内で
ビューポートを定義します。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-type">OrthographicCamera</span> <span class="org-variable-name">camera</span>;
<span class="org-type">Viewport</span> <span class="org-variable-name">viewport</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
<span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">create</span> () {
  &#65306;
  camera = <span class="org-keyword">new</span> <span class="org-type">OrthographicCamera</span>(800, 480);
  viewport = <span class="org-keyword">new</span> <span class="org-type">FitViewport</span>(800, 480, camera); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
  &#65306;
}
</pre>
</div>
<p>
 <code>ViewPort</code> はスーパークラスであり、このクラスを継承した様々なクラスがあります。
インスンタンスを設定する際には、用途に応じたViewPort継承クラスを指定する必要があります。
今回は、 <code>FitViewport</code> クラスを利用します。
</p>

<p>
続いて <code>resize</code> メソッドを追加します。 <code>resize</code> メソッドは、 <code>ApplicationListener</code> クラスのメソッドであり、
画面の向きが変わったり、アプリケーションが起動したタイミングなどで呼ばれます。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">resize</span>(<span class="org-type">int</span> <span class="org-variable-name">width</span>, <span class="org-type">int</span> <span class="org-variable-name">height</span>) {
    viewport.update(width, height); 
}
</pre>
</div>
<p>
ビューポートは画面の大きさが変化した時だけ設定すれば良いため、
 <code>resize</code> メソッドから呼びだすだけでよく、 <code>render</code> メソッドなどで呼びだす必要はありません。
</p>

<p>
ここまでの実行結果は下記のとおりです。
</p>

<div class="figure">
<p><img src="/img/libgdx-beginner/2/006.png"  alt="006.png"/></p>
<p>とりあえずビューポートも導入</p>
</div>

<p>
やった、歪みがなくなりました! 
しかし、ここでひとつおかしいことに気づかないでしょうか？
カメラとビューポートのサイズには <code>800x480</code> を設定しました。
でも、このサンプルのウィンドウサイズは <code>640x480</code> です。なぜ表示できるんでしょうか？
</p>

<p>
このままでは、背景となる塗りつぶし色の赤と、ビューポートの枠の区別がつきにくため、
ビューポートの働きがわかりつらくなっています。
そこで、 <code>FitViewPort</code> の動きを分かりやすくするために、大きなサイズの画像を背景として表示してみます。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 背景の追加</h2>
<div class="outline-text-2" id="text-5">
<p>
背景用に次の画像を「右クリ→名前をつけて保存」で保存してください。
</p>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/bg.png"  alt="bg.png"/></p>
<p>背景</p>
</div>

<p>
保存したファイルを下記に追加してください。
</p>
<div class="org-src-container">

<pre class="src src-sh">~/dev/libgdxtest/android/assets/
</pre>
</div>
<p>
下記のように変更します。
</p>

<p>
フィールド
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-type">Texture</span> <span class="org-variable-name">bgImg</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
<span class="org-type">Sprite</span> <span class="org-variable-name">bg</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
</pre>
</div>

<p>
<code>create</code> メソッド 
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">create</span> () {
    :
   <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
   bgImg = <span class="org-keyword">new</span> <span class="org-type">Texture</span>(<span class="org-string">"bg.png"</span>);
   bg = <span class="org-keyword">new</span> <span class="org-type">Sprite</span>(bgImg);
   bg.setScale(2.0f, 2.0f);
   bg.setPosition(-400, -240);
    :
</pre>
</div>
<p>
<code>render</code> メソッド
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">render</span> () {
    :
      batch.setProjectionMatrix(camera.combined);
    batch.begin();
    bg.draw(batch); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
    sprite.draw(batch);
    sprite2.draw(batch);
    :
</pre>
</div>

<p>
<code>dispose</code> メソッド
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">dispose</span>() {
     :
    bgImg.dispose();
}
</pre>
</div>

<p>
これで実行してみます。
</p>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/007.png"  alt="007.png"/></p>
<p>背景を追加</p>
</div>

<p>
するとどうでしょう？赤い枠が上下に出現しています。
これは、 <code>FitViewPort</code> がウィンドウサイズからビューポートのサイズを自動計算して
当初の縦横比を保ってくれるからなのです。
</p>

<p>
試しにウィンドウサイズを色々マウスでドラッグして変化させてみてください。
</p>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/008.png"  alt="008.png"/></p>
<p>ウィンドウを横長にしてみた</p>
</div>



<div class="figure">
<p><img src="/img/libgdx-beginner/2/009.png"  alt="009.png"/></p>
<p>ウィンドウを縦長にしてみた</p>
</div>

<p>
こんな風に画面のサイズに応じて、ビューポートのサイズを動的に変化さてくれます。
画面の短い辺に対して最大のサイズを割りあて、長い辺に大してはその比率を調整するようですね。
</p>

<p>
もちろんNexus7の実機でもうまく表示できています。
</p>

<div class="figure">
<p><img src="/img/libgdx-beginner/2/nexus7.png"  alt="nexus7.png"/></p>
<p>ちにみにこれはNexus7の2012年度版</p>
</div>


<p>
このように、 <code>FitViewPort</code> クラスを使うことにより、どのような画面サイズであっても、
こちらの意図したとおりの画面比率で表示されるようになります。
</p>

<p>
<code>ViewPort</code> クラスには他にも様々な種類のクラスがあります。
いろいろ試してみてください。
</p>
<ul class="org-ul">
<li><a href="https://github.com/libgdx/libgdx/wiki/Viewports">https://github.com/libgdx/libgdx/wiki/Viewports</a>
</li>
</ul>
<p>
ちなみに上記ビューポートの解説は、下記のよう辿るといきつけます。
</p>
<ul class="org-ul">
<li><a href="https://github.com/libgdx/libgdx/wiki">https://github.com/libgdx/libgdx/wiki</a> → Scene2d → ViewPort
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> カメラの位置調整</h2>
<div class="outline-text-2" id="text-6">
<p>
以上で、カメラとビューポートの導入を終えたのですが、まだおかしいところがあります。
どこでしょうか？
</p>

<p>
実はスプライト画像がひとつしか表示されてません。本来は2つ表示されているハズなのですが。
最初の時はこうでした。
</p>

<div class="figure">
<p><img src="/img/libgdx-beginner/2/003.png"  alt="003.png"/></p>
<p>PC版の画面(再掲)</p>
</div>

<p>
何が起きているかというと、カメラの位置がおかしいのです。
カメラはスプライトと違って、真ん中が原点となります。
なので、ワールド原点を中心とした枠が表示されているのです。
</p>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/010.png"  alt="010.png"/></p>
<p>カメラはワールド原点(0,0)に位置している</p>
</div>

<p>
左上が(-400,240),右上が(400,240),右下が(400,-240),左下が(-400,-240)の枠となっています。
このために2つめのスプライトがちょうど右上の枠の外に位置しており、画面から消えてしまっているのです。
</p>
</div>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> ワールド軸の描画</h3>
<div class="outline-text-3" id="text-6-1">
<p>
ここで、見た目をわかりやすくするためにワールドの座標軸を描画してみます。
</p>

<p>
インポート
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">graphics</span>.<span class="org-constant">glutils</span>.<span class="org-type">ShapeRenderer</span>;
</pre>
</div>

<p>
フィールド
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-type">ShapeRenderer</span> <span class="org-variable-name">shapeRenderer</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
</pre>
</div>

<p>
<code>create</code> メソッド 
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">create</span> () {
    :
   <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
   shapeRenderer = <span class="org-keyword">new</span> <span class="org-type">ShapeRenderer</span>();
    :
</pre>
</div>
<p>
<code>render</code> メソッド
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">render</span> () {
    :
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#12527;&#12540;&#12523;&#12489;&#24231;&#27161;&#36600;&#12434;&#25551;&#30011;&#12377;&#12427;&#12290;</span>
  shapeRenderer.setProjectionMatrix(camera.combined);
  shapeRenderer.begin(<span class="org-constant">ShapeRenderer</span>.<span class="org-constant">ShapeType</span>.Line);
  shapeRenderer.setColor(1, 0, 0, 1);
  shapeRenderer.line(-1024, 0, 1024, 0);
  shapeRenderer.setColor(0, 1, 0, 1);
  shapeRenderer.line(0, -1024, 0, 1024);
  shapeRenderer.end();
    :
</pre>
</div>

<p>
<code>dispose</code> メソッド
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">dispose</span>() {
     :
   shapeRenderer.dispose();
}
</pre>
</div>

<p>
これで実行してみます。
</p>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/012.png"  alt="012.png"/></p>
<p>カメラをsetToOrthoした結果</p>
</div>

<p>
X軸を赤、Y軸を緑で描画しています。
これで状況がよりわかりやすくなったと思います。
</p>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> setToOrthメソッド</h3>
<div class="outline-text-3" id="text-6-2">
<p>
画面の原点を左下に調整するというのはよくあることなので、
専用のメソッドが用意されています。
</p>

<p>
そこで試しに下記のメソッドを追記してみましょう。
</p>

<p>
<code>create</code> メソッド 
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">create</span> () {
    :
   camera = <span class="org-keyword">new</span> <span class="org-type">OrthographicCamera</span>(800,480);
   camera.setToOrtho(<span class="org-constant">false</span>, 800, 480);    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
    :
}
</pre>
</div>
<p>
<code>Camera#setToOrtho</code> メソッドは、カメラを右上に移動させて、左下に丁度ワールド原点がくるように調整するものです。
第1引数は、ydownといって、trueにするとY軸が反転されますが、通常はfalseで良いと思います。
第2引数と第3引数は、カメラのの幅と高さです。 <code>setToOrth</code> をコンストラクタに続けて指定する時は、
コンストラクタには、サイズ指定はいらないですね(今回は修正が面倒なのでそのまま)。
</p>

<p>
これを実行すると以下のように表示されます。
</p>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/013.png"  alt="013.png"/></p>
<p>カメラをsetToOrthoした結果</p>
</div>

<p>
無事カメラが移動されて、2つ目のスプライトも表示されるようになりました。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> カメラを動かす</h2>
<div class="outline-text-2" id="text-7">
<p>
こんどはカメラをキーボードで動かしてみましょう。
</p>

<p>
<code>render</code> メソッドで下記のように追記します。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">render</span> () {
    <span class="org-keyword">if</span> (Gdx.input.isKeyPressed(<span class="org-constant">Input</span>.<span class="org-constant">Keys</span>.LEFT)) {
        <span class="org-comment-delimiter">//</span><span class="org-comment">pos.x -= 1;            // &#21066;&#38500;</span>
        camera.position.x -= 2;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
    }
    <span class="org-keyword">if</span> (Gdx.input.isKeyPressed(<span class="org-constant">Input</span>.<span class="org-constant">Keys</span>.RIGHT)) {
        <span class="org-comment-delimiter">//</span><span class="org-comment">pos.x += 1;            // &#21066;&#38500;</span>
        camera.position.x += 2;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
    }
    <span class="org-keyword">if</span> (Gdx.input.isKeyPressed(<span class="org-constant">Input</span>.<span class="org-constant">Keys</span>.UP)) {
        <span class="org-comment-delimiter">//</span><span class="org-comment">pos.y += 1;            // &#21066;&#38500;</span>
        camera.position.y += 2;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
    }
    <span class="org-keyword">if</span> (Gdx.input.isKeyPressed(<span class="org-constant">Input</span>.<span class="org-constant">Keys</span>.DOWN)) {
        <span class="org-comment-delimiter">//</span><span class="org-comment">pos.y -= 1;            // &#21066;&#38500;</span>
        camera.position.y -= 2;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
    }
</pre>
</div>
<p>
<code>pos</code> ベクトルへの処理を削除し、変わりに <code>camera.position</code> への処理を追加します。
これを実行すると以下のように表示されます。
</p>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/014.png"  alt="014.png"/></p>
<p>カメラを動かしている様子</p>
</div>

<p>
カーソルキーでカメラを動かしてみてください。
背景のBG画像があまり大きくないので端にいくと表示が変な見ためになるので注意です。
</p>

<p>
ここで、カメラが本当に動いているのか数値からも判断するため、
カメラの座標を表示してみます。
</p>

<p>
<code>render</code> メソッドで下記のように追記します。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">render</span> () {
  &#65306;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#12459;&#12513;&#12521;&#12398;&#24231;&#27161;&#12398;&#25991;&#23383;&#21015;&#12434;&#20316;&#12387;&#12390;</span>
  String info = String.format(<span class="org-string">"cam pos(%f,%f)"</span>, camera.position.x, camera.position.y);


  batch.setProjectionMatrix(camera.combined);
  batch.begin();
      &#65306;
  font.draw(batch, info, 0, 20); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
      &#65306;
  batch.begin();
</pre>
</div>
<p>
座標は大体左したに表示されるように指定しています。
</p>

<p>
これを実行すると以下のように表示されます。
</p>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/015.png"  alt="015.png"/></p>
<p>カメラの座標を表示してみる</p>
</div>

<p>
左下に表示されてますね。ではカーソルキーでカメラを動かしてみてください。
</p>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/016.png"  alt="016.png"/></p>
<p>カメラの座標文字がついてこない？!</p>
</div>

<p>
あれ、期待した動きと違ってませんか？ 私は違いました。
どう動いて欲しかったというと、画面にひっついて常に左下に表示して欲しいと思いました。
</p>

<p>
実は、このフォント描画はワールド座標に対して行なわれているのです。
フォント文字もワールドに存在するスプライトと同じオブジェクトとして
描画されているんですね。
</p>

<p>
これを画面にひっつかせて描画させるには、ひと工夫必要です。
</p>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> UI用カメラの導入</h2>
<div class="outline-text-2" id="text-8">
<p>
答えは簡単です。もうひとつカメラを用意すれば良いのです。
UI専用のカメラを準備して、そのカメラは動かさずにおく。
これだけでオッケーです(libGDXのサンプルでもやっている方法です)。
</p>


<p>
フィールド
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-type">OrthographicCamera</span> <span class="org-variable-name">uiCamera</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
</pre>
</div>

<p>
<code>create</code> メソッド 
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">create</span> () {
    :
   <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
   uiCamera = <span class="org-keyword">new</span> <span class="org-type">OrthographicCamera</span>();
   uiCamera.setToOrtho(<span class="org-constant">false</span>, 800, 480);
    :
</pre>
</div>
<p>
<code>render</code> メソッド
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">render</span> () {
    :
  <span class="org-comment-delimiter">//</span><span class="org-comment">font.draw(batch, info, 0, 20);</span>
  <span class="org-comment-delimiter">//</span><span class="org-comment">font.draw(batch, "Hello libGDX", 200, 400);</span>
    :
  <span class="org-comment-delimiter">// </span><span class="org-comment">render &#12398;&#19968;&#30058;&#26368;&#24460;&#12391;&#25551;&#30011;&#12377;&#12427;&#12371;&#12392;</span>
  uiCamera.update();
      batch.setProjectionMatrix(uiCamera.combined);
  batch.begin();
  font.draw(batch, info, 0, 20);
  font.draw(batch, <span class="org-string">"Hello libGDX"</span>, 200, 400);
  batch.end();
}
</pre>
</div>

<p>
以前の <code>font.draw</code> はコメントアウトもしくは、削除します。
注意すべき点は、UIの描画物は <code>render</code> メソッド内の一番最後で描画するということです。
これは、画面上の一番上に描画するためです。
</p>

<p>
実行してみます。
</p>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/017.png"  alt="017.png"/></p>
<p>UIカメラを追加してみた</p>
</div>

<p>
おおお、無事希望どおりの動きになりました!
</p>


<p>
さて、ここで気になることがあります。
それは、画面サイズとして <code>800x480</code> を指定しているにも関わらず、
ウィンドウサイズが <code>640x480</code> のままだということです。
</p>
</div>

<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> Windowサイズの変更</h3>
<div class="outline-text-3" id="text-8-1">
<p>
スマホなどの端末は、ハードウェアなので画面サイズを変更できませんが、
Desktop版は、ウィンドウなので、初期サイズを変更できます。
</p>

<p>
下記のファイルを編集すればオッケーです。
</p>
<div class="org-src-container">

<pre class="src src-sh">~/dev/libgdxtest/desktop/src/com/zarudama/libgdxtest/desktop/DesktopLauncher.java
</pre>
</div>
<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">public</span> <span class="org-keyword">class</span> <span class="org-type">DesktopLauncher</span> {
        <span class="org-keyword">public</span> <span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">main</span> (<span class="org-type">String</span>[] <span class="org-variable-name">arg</span>) {
                <span class="org-type">LwjglApplicationConfiguration</span> <span class="org-variable-name">config</span> = <span class="org-keyword">new</span> <span class="org-type">LwjglApplicationConfiguration</span>();
                config.width = 800;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
                config.height = 480; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36861;&#21152;</span>
                <span class="org-keyword">new</span> <span class="org-type">LwjglApplication</span>(<span class="org-keyword">new</span> <span class="org-type">LibGdxSample</span>(), config);
        }
}
</pre>
</div>

<p>
実行結果です。
</p>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/018.png"  alt="018.png"/></p>
<p>UIカメラを追加してみた</p>
</div>

<p>
画面サイズと論理サイズが一致したので赤い帯がなくなりましたね!
</p>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> タッチ処理</h2>
<div class="outline-text-2" id="text-9">
<p>
いよいよ最後のお題です。私も疲れてきました^^。
</p>

<p>
前回は、キーボード入力の処理方法は学んだものの
スマホ特有の処理、タッチ操作の処理方法は先送りにしていました。
</p>

<p>
指でタッチしているかどうかを検知するには、 <code>Gdx.input.isTouched</code> メソッドを使用します。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">if</span> (Gdx.input.isTouched(0)) {
    :
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#12394;&#12395;&#12363;&#12398;&#20966;&#29702;</span>
    :
}
</pre>
</div>
<p>
このメソッドの引数には番号が必要ですが、これはタッチした指の番号です。
最初にタッチした指の番号は0, 2番目にタッチした座標の番号は1という具合です。
</p>

<p>
タッチの座標を得るには、 <code>Gdx.input.getX</code> , <code>Gdx.input.getY</code> メソッドを使用します。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-type">float</span> <span class="org-variable-name">x0</span> = Gdx.input.getX(0);
<span class="org-type">float</span> <span class="org-variable-name">y0</span> = Gdx.input.getY(0);
</pre>
</div>
<p>
番号は先程の説明と同じ意味です。
</p>

<p>
ただしこの座標、注意が必要で、得られる座標は、画面左上を原点とします。
</p>

<p>
x座標は左から右、Y座標は上から下に伸びます。
</p>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/screen.png"  alt="screen.png"/></p>
<p>スクリーン座標系</p>
</div>

<p>
この座標系は一般的にはスクリーン座標系などと呼ばれ、
最終的な絶対座標(物理座標)として使われるものですが、libGDXでは左下を原点とした
座標のためこのままでは使用できません。
</p>

<p>
ただし私たちは今回カメラを導入しています。なのでカメラの便利メソッドで簡単に変換できます。
こんな感じです。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-type">Vector3</span> <span class="org-variable-name">touchPos</span> = <span class="org-keyword">new</span> <span class="org-type">Vector3</span>();
touchPos.set(Gdx.input.getX(), Gdx.input.getY(), 0);
camera.unproject(touchPos); <span class="org-comment-delimiter">// </span><span class="org-comment">#1</span>
targetPos.set(touchPos.x, touchPos.y);
</pre>
</div>
<p>
<code>#1</code> で、スクリーン座標で得た左上を原点とした座標をワールドの座標に変換します。
</p>

<p>
この処理を <code>if</code> で囲ってあげれば判定処理の出来あがりです。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">if</span> (Gdx.input.isTouched(0)) {
  <span class="org-type">Vector3</span> <span class="org-variable-name">touchPos</span> = <span class="org-keyword">new</span> <span class="org-type">Vector3</span>();
  touchPos.set(Gdx.input.getX(), Gdx.input.getY(), 0);
  camera.unproject(touchPos); <span class="org-comment-delimiter">// </span><span class="org-comment">#1</span>
  targetPos.set(touchPos.x, touchPos.y);
}
</pre>
</div>
<p>
<code>Gdx.input.isTouched</code> メソッドは、タッチし続けてれば、毎フレーム「真」になります。
</p>

<p>
他にタッチを検出するメソッドとして、
 <code>Gdx.input.justTouched</code> メソッドがあります。
このメソッドは、ひとつ前のフレームにタッチしていた場合は、偽になります。
どういうことかというと、押しっぱなしにしてた場合は、
最初の一回しか真にならないということです。
</p>

<p>
例えば、下記のようなコードで、タッチした時だけ音を鳴らすことができます。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">if</span> (Gdx.input.justTouched()) {
    sound.play();
}
</pre>
</div>

<p>
ちなみにjustTouchedと同等の機能のキーボード版のメソッドはありません。
恐らく、このメソッドの実装には、状態変数の保持が必要になってくるので、
そこをライブラリ側で実装してしまうと無駄が多くなるので、
ユーザー側に任せたのだと思います。
</p>

<p>
では、上記の説明をもとに、スプライトをタッチした場所へ移動させるコードを追加します。
下記のように修正してみてください。
</p>

<p>
インポート
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">math</span>.<span class="org-type">Vector3</span>;
</pre>
</div>

<p>
フィールド。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-type">Vector2</span> <span class="org-variable-name">targetPos</span>;
</pre>
</div>

<p>
<code>render</code> メソッド。キーボード処理の直後に追加します。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">if</span> (Gdx.input.isKeyPressed(<span class="org-constant">Input</span>.<span class="org-constant">Keys</span>.DOWN)) {
    pos.y -= 1;
    camera.position.y -= 2;
}
 :
<span class="org-comment-delimiter">// </span><span class="org-comment">&#8595;&#36861;&#21152;</span>
<span class="org-keyword">if</span> (Gdx.input.justTouched()) {
     sound.play();
}
<span class="org-keyword">if</span> (Gdx.input.isTouched(0)) {
  <span class="org-type">Vector3</span> <span class="org-variable-name">touchPos</span> = <span class="org-keyword">new</span> <span class="org-type">Vector3</span>();
  touchPos.set(Gdx.input.getX(), Gdx.input.getY(), 0);
  camera.unproject(touchPos);
  targetPos.set(touchPos.x, touchPos.y);
}
<span class="org-comment-delimiter">// </span><span class="org-comment">&#8593;&#36861;&#21152;</span>
 :
String info = String.format(<span class="org-string">"cam pos(%f,%f)"</span>, camera.position.x, camera.position.y);
</pre>
</div>

<div class="org-src-container">

<pre class="src src-java"><span class="org-c-annotation">@Override</span>
<span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">render</span> () {
   &#65306;
  pos.lerp(targetPos, 0.2f);
  sprite.setPosition(pos.x, pos.y);
   &#65306;
}
</pre>
</div>

<p>
<code>render</code> メソッド内で実行している <code>pos.lerp</code> メソッドは、第一引数の座標
へ値を少しずつ近づけていく処理を実施します。「最初早くて後おそく」って感じの動きです。
</p>

<p>
では、実行してみます。
</p>


<div class="figure">
<p><img src="/img/libgdx-beginner/2/019.png"  alt="019.png"/></p>
<p>マウスでクリックすると、音を鳴らしながら移動します</p>
</div>

<p>
これまでのコードを忠実に入力していれば、音をビヨーンとならしながら移動します。
</p>

<p>
以上で今回の解説は終了です。お疲れさまでした。
</p>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> ソース</h2>
<div class="outline-text-2" id="text-10">
<p>
最後に今回のソースコードを掲載しておきます。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">package</span> com.zarudama.<span class="org-constant">libgdxtest</span>;

<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-type">ApplicationAdapter</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-type">Gdx</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-type">Input</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">audio</span>.<span class="org-type">Music</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">audio</span>.<span class="org-type">Sound</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">graphics</span>.<span class="org-type">GL20</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">graphics</span>.<span class="org-type">OrthographicCamera</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">graphics</span>.<span class="org-type">PerspectiveCamera</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">graphics</span>.<span class="org-type">Camera</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">graphics</span>.<span class="org-type">Texture</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">graphics</span>.<span class="org-constant">g2d</span>.<span class="org-type">BitmapFont</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">graphics</span>.<span class="org-constant">g2d</span>.<span class="org-type">Sprite</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">graphics</span>.<span class="org-constant">g2d</span>.<span class="org-type">SpriteBatch</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">math</span>.<span class="org-type">Vector2</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">math</span>.<span class="org-type">Vector3</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">utils</span>.<span class="org-constant">viewport</span>.<span class="org-type">FitViewport</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">utils</span>.<span class="org-constant">viewport</span>.<span class="org-type">FillViewport</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">utils</span>.<span class="org-constant">viewport</span>.<span class="org-type">StretchViewport</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">utils</span>.<span class="org-constant">viewport</span>.<span class="org-type">ScreenViewport</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">utils</span>.<span class="org-constant">viewport</span>.<span class="org-type">ExtendViewport</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">utils</span>.<span class="org-constant">viewport</span>.<span class="org-type">Viewport</span>;
<span class="org-keyword">import</span> <span class="org-constant">com</span>.<span class="org-constant">badlogic</span>.<span class="org-constant">gdx</span>.<span class="org-constant">graphics</span>.<span class="org-constant">glutils</span>.<span class="org-type">ShapeRenderer</span>;

<span class="org-keyword">public</span> <span class="org-keyword">class</span> <span class="org-type">LibGdxSample</span> <span class="org-keyword">extends</span> <span class="org-type">ApplicationAdapter</span> {
    <span class="org-type">SpriteBatch</span> <span class="org-variable-name">batch</span>;
    <span class="org-type">BitmapFont</span> <span class="org-variable-name">font</span>;
    <span class="org-type">Texture</span> <span class="org-variable-name">img</span>;
    <span class="org-type">Sprite</span> <span class="org-variable-name">sprite</span>;
    <span class="org-type">Sprite</span> <span class="org-variable-name">sprite2</span>;
    <span class="org-type">Vector2</span> <span class="org-variable-name">pos</span>;
    <span class="org-type">Sound</span> <span class="org-variable-name">sound</span>;
    <span class="org-type">Music</span> <span class="org-variable-name">music</span>;
    <span class="org-type">float</span> <span class="org-variable-name">angle</span>;
    <span class="org-type">OrthographicCamera</span> <span class="org-variable-name">camera</span>;
    <span class="org-type">Viewport</span> <span class="org-variable-name">viewport</span>;

    <span class="org-type">Texture</span> <span class="org-variable-name">bgImg</span>;
    <span class="org-type">Sprite</span> <span class="org-variable-name">bg</span>;
    <span class="org-type">ShapeRenderer</span> <span class="org-variable-name">shapeRenderer</span>;

    <span class="org-type">OrthographicCamera</span> <span class="org-variable-name">uiCamera</span>;

    <span class="org-type">Vector2</span> <span class="org-variable-name">targetPos</span>;

    <span class="org-c-annotation">@Override</span>
    <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">create</span> () {
        batch = <span class="org-keyword">new</span> <span class="org-type">SpriteBatch</span>();
        font = <span class="org-keyword">new</span> <span class="org-type">BitmapFont</span>();
        img = <span class="org-keyword">new</span> <span class="org-type">Texture</span>(<span class="org-string">"badlogic.jpg"</span>);
        sprite = <span class="org-keyword">new</span> <span class="org-type">Sprite</span>(img);
        sprite2 = <span class="org-keyword">new</span> <span class="org-type">Sprite</span>(img);
        pos = <span class="org-keyword">new</span> <span class="org-type">Vector2</span>();
        sound = Gdx.audio.newSound(Gdx.files.internal(<span class="org-string">"jump.wav"</span>));
        music = Gdx.audio.newMusic(Gdx.files.internal(<span class="org-string">"mixdown.mp3"</span>));
        music.setLooping(<span class="org-constant">true</span>);
        music.setVolume(0.5f);
        music.play();

        bgImg = <span class="org-keyword">new</span> <span class="org-type">Texture</span>(<span class="org-string">"bg.png"</span>);
        bg = <span class="org-keyword">new</span> <span class="org-type">Sprite</span>(bgImg);
        bg.setScale(2.0f, 2.0f);
        bg.setPosition(-400, -240);

        camera = <span class="org-keyword">new</span> <span class="org-type">OrthographicCamera</span>(800,480);
        camera.setToOrtho(<span class="org-constant">false</span>, 800, 480);
        viewport = <span class="org-keyword">new</span> <span class="org-type">FitViewport</span>(800, 480, camera);

        uiCamera = <span class="org-keyword">new</span> <span class="org-type">OrthographicCamera</span>();
        uiCamera.setToOrtho(<span class="org-constant">false</span>, 800, 480);

        shapeRenderer = <span class="org-keyword">new</span> <span class="org-type">ShapeRenderer</span>();

        targetPos = <span class="org-keyword">new</span> <span class="org-type">Vector2</span>();
    }

    <span class="org-c-annotation">@Override</span>
    <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">resize</span>(<span class="org-type">int</span> <span class="org-variable-name">width</span>, <span class="org-type">int</span> <span class="org-variable-name">height</span>) {
        viewport.update(width, height);
    }

    <span class="org-c-annotation">@Override</span>
    <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">render</span> () {
        <span class="org-keyword">if</span> (Gdx.input.isKeyPressed(<span class="org-constant">Input</span>.<span class="org-constant">Keys</span>.LEFT)) {
            camera.position.x -= 2;
        }
        <span class="org-keyword">if</span> (Gdx.input.isKeyPressed(<span class="org-constant">Input</span>.<span class="org-constant">Keys</span>.RIGHT)) {
            camera.position.x += 2;
        }
        <span class="org-keyword">if</span> (Gdx.input.isKeyPressed(<span class="org-constant">Input</span>.<span class="org-constant">Keys</span>.UP)) {
            camera.position.y += 2;
        }
        <span class="org-keyword">if</span> (Gdx.input.isKeyPressed(<span class="org-constant">Input</span>.<span class="org-constant">Keys</span>.DOWN)) {
            camera.position.y -= 2;
        }
        <span class="org-keyword">if</span> (Gdx.input.justTouched()) {
            sound.play();
        }
                <span class="org-keyword">if</span> (Gdx.input.isTouched(0)) {
            <span class="org-type">Vector3</span> <span class="org-variable-name">touchPos</span> = <span class="org-keyword">new</span> <span class="org-type">Vector3</span>();
            touchPos.set(Gdx.input.getX(), Gdx.input.getY(), 0);
            camera.unproject(touchPos);
            targetPos.set(touchPos.x, touchPos.y);
        }
        <span class="org-type">String</span> <span class="org-variable-name">info</span> = String.format(<span class="org-string">"cam pos(%f,%f)"</span>, camera.position.x, camera.position.y);

        <span class="org-keyword">if</span> (Gdx.input.isKeyPressed(<span class="org-constant">Input</span>.<span class="org-constant">Keys</span>.SPACE)) {
            sound.play();
        }
        pos.lerp(targetPos, 0.2f);
        sprite.setPosition(pos.x, pos.y);
        sprite.setScale((<span class="org-type">float</span>) Math.sin(angle));
        angle += 0.04;

        sprite2.setRotation(angle);
        sprite2.setPosition(200, 300);
        sprite2.setRotation(angle);

        Gdx.gl.glClearColor(1, 0, 0, 1);
        Gdx.gl.glClear(<span class="org-constant">GL20</span>.GL_COLOR_BUFFER_BIT);
        camera.update(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#12527;&#12540;&#12523;&#12489;&#12363;&#12425;&#12473;&#12463;&#12522;&#12540;&#12531;&#12414;&#12391;&#12398;&#12510;&#12488;&#12522;&#12483;&#12463;&#12473;&#12434;&#29983;&#25104;&#12377;&#12427;&#12290;</span>
        batch.setProjectionMatrix(camera.combined);
        batch.begin();
        bg.draw(batch);
        sprite.draw(batch);
        sprite2.draw(batch);
        batch.end();

        <span class="org-comment-delimiter">// </span><span class="org-comment">&#12527;&#12540;&#12523;&#12489;&#24231;&#27161;&#36600;&#12434;&#25551;&#30011;&#12377;&#12427;&#12290;</span>
        shapeRenderer.setProjectionMatrix(camera.combined);
        shapeRenderer.begin(<span class="org-constant">ShapeRenderer</span>.<span class="org-constant">ShapeType</span>.Line);
        shapeRenderer.setColor(1, 0, 0, 1);
        shapeRenderer.line(-1024, 0, 1024, 0);
        shapeRenderer.setColor(0, 1, 0, 1);
        shapeRenderer.line(0, -1024, 0, 1024);
        shapeRenderer.end();

        uiCamera.update(); <span class="org-comment-delimiter">// </span><span class="org-comment">uiCamera&#12434;&#21205;&#12363;&#12373;&#12394;&#12356;&#12398;&#12391;&#12354;&#12428;&#12400;&#12289;&#24517;&#35201;&#12394;&#12356;&#12290;</span>
        batch.setProjectionMatrix(uiCamera.combined);
        batch.begin();
        font.draw(batch, info, 0, 20);
        font.draw(batch, <span class="org-string">"Hello libGDX"</span>, 200, 400);
        batch.end();
    }

    <span class="org-c-annotation">@Override</span>
    <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">dispose</span>() {
        sound.dispose();
        music.dispose();
        batch.dispose();
        font.dispose();
        img.dispose();
        bgImg.dispose();
        shapeRenderer.dispose();
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> おわりに</h2>
<div class="outline-text-2" id="text-11">
<p>
面倒だけど重要な説明が終りました。
これで、端末の画面サイズを気にせずプログラミングできるようになりました。
次回は、そろそろゲームっぽいものをつくろうかなと思います。
予定している内容は、
</p>
<ul class="org-ul">
<li>アニメーション処理
</li>
<li>画面遷移
</li>
<li>2DScene
</li>
</ul>
<p>
などです。
</p>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> 参考URL</h2>
<div class="outline-text-2" id="text-12">
<p>
ビューポートについては下記にも詳しい内容があります。合せて読めば理解も深まると思います。
</p>
<ul class="org-ul">
<li><a href="http://qiita.com/fslasht/items/13dbf31277ad43e50b85">http://qiita.com/fslasht/items/13dbf31277ad43e50b85</a>
</li>
<li><a href="http://qiita.com/fslasht/items/c0830eaf05b7a91b8e85">http://qiita.com/fslasht/items/c0830eaf05b7a91b8e85</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> 参考書籍</h2>
<div class="outline-text-2" id="text-13">
<div class="figure" style="float:left">
<a href="http://www.amazon.co.jp/gp/product/4844331132/ref=as_li_qf_sp_asin_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4844331132&linkCode=as2&tag=ocha04-22"><img border="0" src="http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=4844331132&Format=_SL250_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=ocha04-22" ></a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=ocha04-22&l=as2&o=9&a=4844331132" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
</div>
<p>
libGDXの作者が書いた本です。Androidでゲームを作るための基本を独自のフレームワーク作成を通して解説しています。
libGDXの解説ではないけれど、その思想は当然libGDXにも引き継がれています。もちろんlibGDXの理解もしやすくなります。
また、Androidの本ではありますが、スマホに特化した内容ばかりではなく、
どんなゲーム開発にも通用しそうな内容ばかりです。
実践的かつ基本的で自分は退屈せずに読めました(特にMVCについての言及が良い)。
そういう意味でこの本は、すべての初級ゲーム開発者におすすめできる本かと思います。
ただし一部内容が古いので注意してください(沢山売れて第2版が翻訳されればいいんですが)。
それでもlibGDXをやるなら読んでいて損はないと思います。
</p>
<div style="clear:both;"></div>
</div>
</div>
  <footer class="article-footer">
    <nav class="tag">
      <ul>
                <li><span><a href="/tag/libGDX.html">libGDX</a></span></li>
                <li><span><a href="/tag/libGDX入門.html">libGDX入門</a></span></li>
        
      </ul>
    </nav>
    <nav>
      <ul class="pager">
        
        &nbsp;&nbsp;
                <li class="next"><a href="/article/2014/06/01_cask.html">Caskの導入と設定ファイルの棚卸し&nbsp;&raquo;</a></li>
        
      </ul>
    </nav>
  </footer>

  <div id="disqus_thread"></div>
  <script type="text/javascript">
   /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
   var disqus_shortname = 'mikiokunblog';

   /* * * DON'T EDIT BELOW THIS LINE * * */
   (function() {
     var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
     dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
   })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

                <script type="text/javascript" src="/js/main.js"></script>
        
        <script type="text/javascript">

         var _gaq = _gaq || [];
         _gaq.push(['_setAccount', 'UA-30203998-1']);
         _gaq.push(['_trackPageview']);

         (function() {
           var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
           ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
           var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
         })();

        </script>
      </div>
    </div>

    <div class="footer">
      <div class="misaki-logo">
        <p>
          <a href="https://github.com/mikio/misaki-orgmode" title="generated by Misaki orgmode">
            <img src="/img/misaki-orgmode-large-banner.png"/></a>
        </p>
        <p>Based on <a href="https://github.com/liquidz/misaki">Miaski</a>.</p>
        <p>This site is built with <a href="http://purecss.io">Pure</a> CSS Framework.</p>
        <p><a href="http://twitter.com/mikio_kun">@mikio_kun</a> 2014</p>
      </div>
    </div>
  </body>
</html>